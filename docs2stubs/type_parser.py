#!/usr/bin/env python3.8
# @generated by pegen from grammar.peg

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: ((type_line NEWLINE))*
        # nullable=True
        mark = self._mark()
        if (
            (_loop0_1 := self._loop0_1(),)
        ):
            return _loop0_1
        self._reset(mark)
        return None

    @memoize
    def type_line(self) -> Optional[Any]:
        # type_line: type_list ['or' 'None']
        mark = self._mark()
        if (
            (type_list := self.type_list())
            and
            (opt := self._tmp_2(),)
        ):
            return [type_list, opt]
        self._reset(mark)
        return None

    @memoize
    def type_list(self) -> Optional[Any]:
        # type_list: type (((',' | 'or') type))*
        mark = self._mark()
        if (
            (type := self.type())
            and
            (_loop0_3 := self._loop0_3(),)
        ):
            return [type, _loop0_3]
        self._reset(mark)
        return None

    @memoize
    def type(self) -> Optional[Any]:
        # type: basic_type | alt_type | array_like | restricted_type
        mark = self._mark()
        if (
            (basic_type := self.basic_type())
        ):
            return basic_type
        self._reset(mark)
        if (
            (alt_type := self.alt_type())
        ):
            return alt_type
        self._reset(mark)
        if (
            (array_like := self.array_like())
        ):
            return array_like
        self._reset(mark)
        if (
            (restricted_type := self.restricted_type())
        ):
            return restricted_type
        self._reset(mark)
        return None

    @memoize
    def alt_type(self) -> Optional[Any]:
        # alt_type: '{' array_kind ((',' array_kind))* '}' array_qualifier?
        mark = self._mark()
        if (
            (literal := self.expect('{'))
            and
            (array_kind := self.array_kind())
            and
            (_loop0_4 := self._loop0_4(),)
            and
            (literal_1 := self.expect('}'))
            and
            (opt := self.array_qualifier(),)
        ):
            return [literal, array_kind, _loop0_4, literal_1, opt]
        self._reset(mark)
        return None

    @memoize
    def array_like(self) -> Optional[Any]:
        # array_like: array_kind array_qualifier?
        mark = self._mark()
        if (
            (array_kind := self.array_kind())
            and
            (opt := self.array_qualifier(),)
        ):
            return [array_kind, opt]
        self._reset(mark)
        return None

    @memoize
    def array_kind(self) -> Optional[Any]:
        # array_kind: 'ndarray' | 'matrix' | 'sparse' 'matrix'
        mark = self._mark()
        if (
            (literal := self.expect('ndarray'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('matrix'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('sparse'))
            and
            (literal_1 := self.expect('matrix'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        return None

    @memoize
    def array_qualifier(self) -> Optional[Any]:
        # array_qualifier: shape_qualifier | type_qualifier
        mark = self._mark()
        if (
            (shape_qualifier := self.shape_qualifier())
        ):
            return shape_qualifier
        self._reset(mark)
        if (
            (type_qualifier := self.type_qualifier())
        ):
            return type_qualifier
        self._reset(mark)
        return None

    @memoize
    def shape_qualifier(self) -> Optional[Any]:
        # shape_qualifier: 'of' 'shape' '(' NAME ((',' NAME))* ')'
        mark = self._mark()
        if (
            (literal := self.expect('of'))
            and
            (literal_1 := self.expect('shape'))
            and
            (literal_2 := self.expect('('))
            and
            (name := self.name())
            and
            (_loop0_5 := self._loop0_5(),)
            and
            (literal_3 := self.expect(')'))
        ):
            return [literal, literal_1, literal_2, name, _loop0_5, literal_3]
        self._reset(mark)
        return None

    @memoize
    def type_qualifier(self) -> Optional[Any]:
        # type_qualifier: 'of' basic_type
        mark = self._mark()
        if (
            (literal := self.expect('of'))
            and
            (basic_type := self.basic_type())
        ):
            return [literal, basic_type]
        self._reset(mark)
        return None

    @memoize
    def basic_type(self) -> Optional[Any]:
        # basic_type: 'int' | 'str' | 'float' | 'floats'
        mark = self._mark()
        if (
            (literal := self.expect('int'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('str'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('float'))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('floats'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def restricted_type(self) -> Optional[Any]:
        # restricted_type: '{' STRING ((',' STRING))* '}'
        mark = self._mark()
        if (
            (literal := self.expect('{'))
            and
            (string := self.string())
            and
            (_loop0_6 := self._loop0_6(),)
            and
            (literal_1 := self.expect('}'))
        ):
            return [literal, string, _loop0_6, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: (type_line NEWLINE)
        mark = self._mark()
        children = []
        while (
            (_tmp_7 := self._tmp_7())
        ):
            children.append(_tmp_7)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_2(self) -> Optional[Any]:
        # _tmp_2: 'or' 'None'
        mark = self._mark()
        if (
            (literal := self.expect('or'))
            and
            (literal_1 := self.expect('None'))
        ):
            return [literal, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _loop0_3(self) -> Optional[Any]:
        # _loop0_3: ((',' | 'or') type)
        mark = self._mark()
        children = []
        while (
            (_tmp_8 := self._tmp_8())
        ):
            children.append(_tmp_8)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: (',' array_kind)
        mark = self._mark()
        children = []
        while (
            (_tmp_9 := self._tmp_9())
        ):
            children.append(_tmp_9)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: (',' NAME)
        mark = self._mark()
        children = []
        while (
            (_tmp_10 := self._tmp_10())
        ):
            children.append(_tmp_10)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_6(self) -> Optional[Any]:
        # _loop0_6: (',' STRING)
        mark = self._mark()
        children = []
        while (
            (_tmp_11 := self._tmp_11())
        ):
            children.append(_tmp_11)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_7(self) -> Optional[Any]:
        # _tmp_7: type_line NEWLINE
        mark = self._mark()
        if (
            (type_line := self.type_line())
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return [type_line, _newline]
        self._reset(mark)
        return None

    @memoize
    def _tmp_8(self) -> Optional[Any]:
        # _tmp_8: (',' | 'or') type
        mark = self._mark()
        if (
            (_tmp_12 := self._tmp_12())
            and
            (type := self.type())
        ):
            return [_tmp_12, type]
        self._reset(mark)
        return None

    @memoize
    def _tmp_9(self) -> Optional[Any]:
        # _tmp_9: ',' array_kind
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (array_kind := self.array_kind())
        ):
            return [literal, array_kind]
        self._reset(mark)
        return None

    @memoize
    def _tmp_10(self) -> Optional[Any]:
        # _tmp_10: ',' NAME
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (name := self.name())
        ):
            return [literal, name]
        self._reset(mark)
        return None

    @memoize
    def _tmp_11(self) -> Optional[Any]:
        # _tmp_11: ',' STRING
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (string := self.string())
        ):
            return [literal, string]
        self._reset(mark)
        return None

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: ',' | 'or'
        mark = self._mark()
        if (
            (literal := self.expect(','))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('or'))
        ):
            return literal
        self._reset(mark)
        return None

    KEYWORDS = ('None', 'matrix', 'int', 'floats', 'of', 'shape', 'sparse', 'or', 'str', 'ndarray', 'float')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
